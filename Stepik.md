Я пишу!


```c
#include <stdio.h> - подключение директивы компилятор
int main(void) {
//тело функции
  return 0;
}
```


```c
printf(); // вывести в консоль
```

Не явные преобразования когда int автоматически преобразуется в double
если переменной не присвоено значение она хранит непонятно что

## printf
### Спецификаторы формата
```c
printf("%d",19) // вы ведет 19
```

то есть, без спецификатора она выводит только строки для того что бы вывести всё остальное нужно писать % и символ
**%d, %i**  - целые числа  
**%f, %g**  - вещественные числа  
%f - в большенстве случаев нужно использовать это
%g - замороченные супер точные дроби для научных чисел
**%c**         - символы
%s - string
что бы вывести знак % нужно напистать  \%\%

### Модификаторы формата

%3.5f - 3 это количество символов (положительное - прижимание по правому краю, отрицательное наоборот), а 5 это после запятой
так же можно ставить -3 что будет прибалять символы
и так же можно использовать "%d.5",7 для прибавления нулей перед числом, например: 00007


## scanf
scanf("%d",&a) - (Спецификатор формата, &- символ что бы перезаписать, куда записать)

когда мы считываем строчку, тогда не нужно ставить &. Это единственный случай когда амперсанд не требуется

**%d**   - целые числа  
**%f**   - вещественное число типа float  
**%lf**  - вещественное число типа double (обозначение lf от long float)  
**%c**   - символ


 Вообще всё должно быть сопоставимо иначе будут ошибки, даже не явно не хочет в принте приобразовывать int в float...

## Строка
Называется - строка символов или строковая константа
В языке СИ допустимо писать строчку с переносом строки
```
printf("%s","первая строка"
"вторая строка")
```
это будет восприниматься как одна строка

## Математика
Деление нацело двух интов - для деления с остатком нужно преобразовать одно число во флоат, иначе деление будет произведено только до целого числа
% - остаток от деления
/ - деление с отбрасывание (усечение) дробной части

### Модуль math
\#include <math.h> подключение модуля
fabs(x) модуль числа x  
sqrt(x) квадратный корень из числа x  
sin(x) синус числа x (х в радианах)  
cos(x) косинус числа x (х в радианах)  
pow(x, y) вычисление x^y  
exp(x) вычисление ex  
log(x) натуральный логарифм числа x  
log10(x) десятичный логарифм числа x

### Функции rand, srand
подключаются через библиотеку stdlib.h
сама функция рад генерирует случайное число, и не имеет ограничивающих параметров. Мы их должны прописать сами.
Для того что бы взять число меньше чем, допустим 17 нам нужно остаточно поделить % 17 и мы получим число от 0 - 16
Что бы взять число от 5 до 17 нам нужно 
0 - 16 прибавить 5 => 5 - 21 
Всё равно пока что не то
далее из второго числа нам нужно отнять 5 и прибавить 1
получается 5 - 17
```C
printf("%d",a + (rand()%b - a + 1);
	   //A + rand()%(B-A+1).
	   // A первый интервал, B второй
```

но генератор у нас будет всегда одинаковый, отталкиваться от одного и тогоже начально числа
для его смены применяется функция srand в которую нужно заложить случайное число, у нас это будет время с начала эпохи
подключается через time.h и для вывода нужного времени требует аргумента NULL
```C
time(NULL);
```


дело в том что эти фкункции выдают тип данный double, мы можем подавать int, он будет неявно преобразован в double.
## Преобразования (явные не явные)
явные преобразования - когда мы перед числом в скобках ставим тип данный к которому нужно преобразоваться 
```C
float a = 45.123445;
res = (int) a /2
```

так же есть не явные преобразования и они работают по своим правилам
1

```C
int a;
// всё приравнивается к тому что в равно, с потерей дробной части ПОСЛЕ ВЫПОЛНЕНИЯ ОПЕРАЦИИ!!
a = 23.34 * 23.44
```
2
```C
23 * 24.12 = 23.34 * 24.12 //при выполнение математических действий будут присваиваться к более точному


```

чтобы использовать русские символы
```C
#include <locale.h>
int main(void) { 
  setlocale(LC_ALL, "");
```

## Оператор switch
```C
switdh(выражение) {
	case1 = one; break
	case2 = two; break

}
```
- выражением строго может быть или int или char
- могут быть вложенными, а так же исполнять любое действие
- если мы не указываем ; break то всё будет выполняться последовательно
## Логические операторы
! - логическое НЕ.
&& - логическое И.
|| - логическое ИЛИ.
### Приоритеты операций
-   Операции в скобках
-   вычисляются функции (например, sqrt(), cos() и др.)
-   Логическая операция НЕ
-   умножение, деление, остаток от деления (слева направо)
-   сложение, вычитание
-   Логическая операция И
-   Логическая операция ИЛИ
-   выполняется присваивание

## Циклы
### For
синтаксис цикла такой 
```C
for (int k = a; k <= b; k++){//обязательно первый элемент нужно инициализировать в цикле
    sum = sum + k;
  }
```
### While
Цикл с предусловием
### do-while
```C
### While
```

## Оператор break; continue
break - работает в любой циклической конструкции и останавливает ближайшую

continue - работатет только в циклах и позволяет сразу перейти к след итерации, а точнее к проверке условия перед следующей итерацией0

## Массивы
имеют тип данных и свою длинну, задаются как переменные с \[длинна]
```C
int arr_int[5] = {2, 5, 5, 3, 4};
```
по какой то причине можно создавать массивы длинной введённой с клавиатуры с мусором, а с нулём нельзя. Я подозреваю что это потому что мусор - занимает максимальное  места, а ноль мало, что бы потом его редактировать.
